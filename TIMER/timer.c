

#include "timer.h"


static bool TIMER_enablePIN_OCn(TIMER_OUTPUT_COMPARE_PIN);

static volatile void (*TIMER_callBackPtrs[8])(void)=
{
		NULL_PTR,   /*TIMER0 OVERFLOW*/
		NULL_PTR,   /*TIMER0 COMPARE*/
		NULL_PTR,	/*TIMER1 OVERFLOW*/
		NULL_PTR,	/*TIMER1A COMPARE*/
		NULL_PTR,	/*TIMER1B COMPARE*/
		NULL_PTR,	/*TIMER1 INPUT CAPTURE*/
		NULL_PTR,	/*TIMER2 OVERFLOW*/
		NULL_PTR,	/*TIMER2 COMPARE*/

};





bool TIMER_enable(const TIMER_NUMBER TIMER_NUM,const TIMER_PRESCALAR TIMER_PRE)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : CLEAR_N_BITS_THEN_OR(TIMER0_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;

	case TIMER_1 : CLEAR_N_BITS_THEN_OR(TIMER1B_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;


	case TIMER_2 : CLEAR_N_BITS_THEN_OR(TIMER2_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;

	}



	return TRUE;
}




bool TIMER_disable(const TIMER_NUMBER TIMER_NUM)
{


	switch(TIMER_NUM)
	{

	case TIMER_0 : TIMER0_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;


	case TIMER_1 : TIMER1B_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;

	case TIMER_2 : TIMER2_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;

	}




	return TRUE;
}



uint16_t TIMER_readCount(const TIMER_NUMBER TIMER_NUM)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : 	return (uint16_t) TIMER0_COUNT_REGISTER;

	case TIMER_1 :  return 			  TIMER1_COUNT_REGISTER;

	case TIMER_2 :	return (uint16_t) TIMER2_COUNT_REGISTER;

	default :		return (uint16_t) TIMER0_COUNT_REGISTER;


	}

}

uint8_t	 TIMER_readStatus(const TIMER_NUMBER TIMER_NUM,const TIMER_CHANNEL TIMER_CHAN,const TIMER_FLAG TIMER_FLAG)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : if(TIMER_FLAG == _OVERFLOW) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER0_OVERFLOW_FLAG);
	else		   return MASK_BITS(TIMER_FLAG_REGISTER,TIMER0_COMPARE_FLAG);

	case TIMER_1 :
		if(TIMER_FLAG == _OVERFLOW)
		{
			return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1_OVERFLOW_FLAG);
		}
		else if (TIMER_FLAG == _INPUT_CAPTURE)
		{
			return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1_INPUT_CAPTURE_FLAG);
		}
		else
		{
			if(TIMER_CHAN == _CHANNEL_A) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1A_COMPARE_FLAG);
			else			     return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1B_COMPARE_FLAG);
		}


	case TIMER_2 : if(TIMER_FLAG == _OVERFLOW) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER2_OVERFLOW_FLAG);
	else		   return MASK_BITS(TIMER_FLAG_REGISTER,TIMER2_COMPARE_FLAG);


	default : return (uint8_t) 0x00;


	}

}




bool TIMER_interruptDisable(const TIMER_NUMBER TIMER_NUMBER,const TIMER_CHANNEL TIMER_CHAN,const TIMER_FLAG TIMER_FLAG)
{

	switch(TIMER_NUMBER)
	{

	case TIMER_0 : if(TIMER_FLAG == _OVERFLOW)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER0_OVERFLOW_FLAG);
	else		    RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER0_COMPARE_FLAG);
	break;


	case TIMER_1 :
		if(TIMER_FLAG == _OVERFLOW)
		{
			RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1_OVERFLOW_FLAG);
		}
		else if(TIMER_FLAG == _INPUT_CAPTURE)
		{

			RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1_INPUT_CAPTURE_FLAG);

		}
		else
		{
			if(TIMER_CHAN == _CHANNEL_A)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1A_COMPARE_FLAG);
			else			  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1B_COMPARE_FLAG);


		}
		break;


	case TIMER_2 : if(TIMER_FLAG == _OVERFLOW)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER2_OVERFLOW_FLAG);
	else			    RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER2_COMPARE_FLAG);
	break;


	}


	return TRUE;
}




void TIMER_COMPARE_setValue(const TIMER_NUMBER TIMER_NUMBER ,const TIMER_CHANNEL TIMER_CHANNEL,const TIMER_MODE TIMER_MODE,const uint16_t compareValue)
{
	uint16_t modifiedValue;

	if(TIMER_NUMBER == TIMER_1)
	{

		if(TIMER_MODE == _PWM_MODE)				modifiedValue= (compareValue*65535)/100;
		else									modifiedValue= compareValue;

		if(TIMER_CHANNEL == _CHANNEL_A)			TIMER1A_COMPARE_REGISTER=modifiedValue;
		else if(TIMER_CHANNEL == _CHANNEL_B)	TIMER1B_COMPARE_REGISTER=modifiedValue;
	}
	else
	{

		if(TIMER_MODE == _CTC_MODE)  		modifiedValue= compareValue & 0x00FF;
		else if(TIMER_MODE == _PWM_MODE)	modifiedValue = (compareValue*255)/100;

		if(TIMER_NUMBER== TIMER_0)			TIMER0_COMPARE_REGISTER= modifiedValue;
		else 								TIMER2_COMPARE_REGISTER= modifiedValue;
	}


}


void TIMER_ICU_setEdge(const TIMER_ICU_EDGE TIMER_EDGE)
{

	CLEAR_N_BITS_THEN_OR(TIMER1B_CONTROL_REGISTER,TIMER_ICU_EGE_CLEAR_MASK,TIMER_EDGE,BIT_6);

}

uint16_t TIMER1_ICU_readCaptureReg()
{
	return TIMER1_INPUT_CAPTURE_REGISTER;
}


static bool TIMER_enablePIN_OCn(TIMER_OUTPUT_COMPARE_PIN COMPARE_PIN)
{

	switch(COMPARE_PIN)
	{

	case _OC0 : SET_BIT(GPIO_PORTB_DIRECTION_REGISTER,BIT_3);
	break;


	case _OC1A : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_5);
	break;

	case _OC1B : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_4);
	break;

	case _OC2 : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_7);
	break;

	}


	return TRUE;
}





/*ISRs*/

void ISR(TIMER0_OVF_vect)
{

	(TIMER_callBackPtrs[0])();

}

void ISR(TIMER0_COMP_vect)
{

	(TIMER_callBackPtrs[1])();

}

void ISR(TIMER1_OVF_vect)
{

	(TIMER_callBackPtrs[2])();

}

void ISR(TIMER1_COMPA_vect)
{

	(TIMER_callBackPtrs[3])();

}

void ISR(TIMER1_COMPB_vect)
{

	(TIMER_callBackPtrs[4])();

}

void ISR(TIMER1_CAPT_vect)
{

	(TIMER_callBackPtrs[5])();

}


void ISR(TIMER2_OVF_vect)
{

	(TIMER_callBackPtrs[6])();

}

void ISR(TIMER2_COMP_vect)
{

	(TIMER_callBackPtrs[7])();

}

