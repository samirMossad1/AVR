

#include "timer.h"


static bool TIMER_enablePIN_OCn(TIMER_OUTPUT_COMPARE_PIN);








bool TIMER_enable(const TIMER_NUMBER TIMER_NUM,const TIMER_PRESCALAR TIMER_PRE)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : CLEAR_N_BITS_THEN_OR(TIMER0_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;

	case TIMER_1 : CLEAR_N_BITS_THEN_OR(TIMER1B_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;


	case TIMER_2 : CLEAR_N_BITS_THEN_OR(TIMER2_CONTROL_REGISTER,CLOCK_TIMER_DISABLE_MASK,TIMER_PRE,0);
	break;

	}



	return TRUE;
}




bool TIMER_disable(const TIMER_NUMBER TIMER_NUM)
{


	switch(TIMER_NUM)
	{

	case TIMER_0 : TIMER0_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;


	case TIMER_1 : TIMER1B_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;

	case TIMER_2 : TIMER2_CONTROL_REGISTER &= ~(CLOCK_TIMER_DISABLE_MASK);
	break;

	}




	return TRUE;
}



uint16_t TIMER_readCount(const TIMER_NUMBER TIMER_NUM)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : 	return (uint16_t) TIMER0_COUNT_REGISTER;

	case TIMER_1 :  return 			  TIMER1_COUNT_REGISTER;

	case TIMER_2 :	return (uint16_t) TIMER2_COUNT_REGISTER;

	default :		return (uint16_t) TIMER0_COUNT_REGISTER;


	}

}

uint8_t	 TIMER_readStatus(const TIMER_NUMBER TIMER_NUM,const TIMER_CHANNEL TIMER_CHAN,const TIMER_FLAG TIMER_FLAG)
{

	switch(TIMER_NUM)
	{

	case TIMER_0 : if(TIMER_FLAG == _OVERFLOW) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER0_OVERFLOW_FLAG);
	else		   return MASK_BITS(TIMER_FLAG_REGISTER,TIMER0_COMPARE_FLAG);

	case TIMER_1 :
		if(TIMER_FLAG == _OVERFLOW)
		{
			return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1_OVERFLOW_FLAG);
		}
		else if (TIMER_FLAG == _INPUT_CAPTURE)
		{
			return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1_INPUT_CAPTURE_FLAG);
		}
		else
		{
			if(TIMER_CHAN == _CHANNEL_A) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1A_COMPARE_FLAG);
			else			     return MASK_BITS(TIMER_FLAG_REGISTER,TIMER1B_COMPARE_FLAG);
		}


	case TIMER_2 : if(TIMER_FLAG == _OVERFLOW) return MASK_BITS(TIMER_FLAG_REGISTER,TIMER2_OVERFLOW_FLAG);
	else		   return MASK_BITS(TIMER_FLAG_REGISTER,TIMER2_COMPARE_FLAG);


	default : return (uint8_t) 0x00;


	}

}




bool TIMER_interruptDisable(const TIMER_NUMBER TIMER_NUMBER,const TIMER_CHANNEL TIMER_CHAN,const TIMER_FLAG TIMER_FLAG)
{

	switch(TIMER_NUMBER)
	{

	case TIMER_0 : if(TIMER_FLAG == _OVERFLOW)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER0_OVERFLOW_FLAG);
	else		    RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER0_COMPARE_FLAG);
	break;


	case TIMER_1 :
		if(TIMER_FLAG == _OVERFLOW)
		{
			RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1_OVERFLOW_FLAG);
		}
		else if(TIMER_FLAG == _INPUT_CAPTURE)
		{

			RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1_INPUT_CAPTURE_FLAG);

		}
		else
		{
			if(TIMER_CHAN == _CHANNEL_A)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1A_COMPARE_FLAG);
						else			  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER1B_COMPARE_FLAG);


		}
		break;


	case TIMER_2 : if(TIMER_FLAG == _OVERFLOW)  RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER2_OVERFLOW_FLAG);
	else			    RESET_BIT(TIMER_INTERRUPT_MASK_REGISTER,TIMER2_COMPARE_FLAG);
	break;


	}


	return TRUE;
}


void TIMER_COMPARE_setValue(const TIMER_NUMBER TIMER_NUMBER ,const TIMER_CHANNEL TIMER_CHANNEL,const uint16_t compareValue)
{

	switch(TIMER_NUMBER)
	{

	case TIMER_0:	TIMER0_COMPARE_REGISTER= compareValue & 0x00FF;
					break;

	case TIMER_1:  if(TIMER_CHANNEL == _CHANNEL_A) 			   TIMER1A_COMPARE_REGISTER= compareValue;
				   else if(TIMER_CHANNEL == _CHANNEL_B)		   TIMER1B_COMPARE_REGISTER= compareValue;
					break;

	case TIMER_2:  	TIMER2_COMPARE_REGISTER= compareValue & 0x00FF;
					break;

	}

}


void TIMER_ICU_setEdge(const TIMER_ICU_EDGE TIMER_EDGE)
{

	CLEAR_N_BITS_THEN_OR(TIMER1B_CONTROL_REGISTER,TIMER_ICU_EGE_CLEAR_MASK,TIMER_EDGE,BIT_6);

}

uint16_t TIMER1_ICU_readCaptureReg()
{
	return TIMER1_INPUT_CAPTURE_REGISTER;
}


static bool TIMER_enablePIN_OCn(TIMER_OUTPUT_COMPARE_PIN COMPARE_PIN)
{

	switch(COMPARE_PIN)
	{

	case _OC0 : SET_BIT(GPIO_PORTB_DIRECTION_REGISTER,BIT_3);
	break;


	case _OC1A : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_5);
	break;

	case _OC1B : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_4);
	break;

	case _OC2 : SET_BIT(GPIO_PORTD_DIRECTION_REGISTER,BIT_7);
	break;

	}


	return TRUE;
}

